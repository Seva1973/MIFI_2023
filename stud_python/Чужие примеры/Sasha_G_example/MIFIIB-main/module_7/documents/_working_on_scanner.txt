Доброе утро! Посмотрел код, давайте по пунктам:
Ошибка
TypeError: int() argument must be a string, a bytes-like object or a real number, not ‘NoneType’
Вылезает, потому что нужно привести строку, которую Вы отправляете на сокет, в необходимый вид. Либо в байты перевести, либо предоставить это питону, закодировав строку в utf-8:
self.wfile.write(f"The list of successfully pinged IP addresses: {ping_list}".encode())
2. Сканируется только один ip адрес, потому что отсутствует цикл, в котором будут перебираться ip адреса. Если я правильно помню, у Вас раньше функция сканирования вызывалась внутри цикла for, который перебирал последние октеты начиная с res[3] до res[3]+num_of_hosts.
А сейчас судя по выводу - функция запускается один раз, берет начальный ip, прибавляет к нему num_of_hosts, получает 120 в последнем октете (115+5) и выводит результат для одного ip адреса. В общем, нужно в функции сделать цикл for для перебора последних октетов. Что-то вроде
for last_octet in num_of_hosts:
   res[3] + last_octet
   response = os.popen(f'ping -c 1 {scanned_ip}')
res = response.readlines()
(Код примерный, работоспособность не проверял: нужно проверить чтобы переменные не перезаписывались)
Думаю, если добавите encode() в возвращение ответа и добавите перебор последних октетов, должно заработать


Константин З.
  17 hours ago
По поводу 3 функций: ping sweep и GET\POST
Как вариант - использовать do_GET для обработки ping sweep, а в do_POST просто парсить приходящее значение метода.
Т.е. важно разделять: то что Вы на API отправляете GET или POST - это просто Ваша реализация API. Вы сами задаете правила как и что отправлять. А вот куда и в каком виде оно потом дальше отправит http request - это можно задавать параметрами. Например, я хочу отправить GET запрос на ya.ru. Тогда:
Отправляю POST запрос на API, а в теле запроса указываю:
{"method": "GET", "url":"https://ya.ru"}
Нужно только реализовать обработчик, чтобы он тело запроса парсил правильно. Здесь может пригодиться библиотека json.
У нее есть метод json.loads(), который выгрузит формат json и сразу его распарсит.
И если я захочу получить значения method (из примера выше):

payload = json.loads(temp)
if method in payload == "GET":
   <отправляем GET запрос>
elif method in payload == "POST":
   <отправляем POST запрос>
Опять же, пишу из головы, так что нужно смотреть детально. Но концепция такая
Если не получится - пишите, будем еще разбираться. И извиняюсь за долгий ответ


Ганицев Александр Сергеевич
  13 hours ago
@Константин З.
Благодарю Константин, что-то понимаю, что-то нет. Самая большая проблема для меня - это когда программа была standalone, я наконец разобрался, как идёт поток выполнения. Теперь, с запуском http server-a я не вижу вывод(!), и мне вообще не понятны изменения, которые я делаю, т.е. как говорил Конфуций: «нельзя искать чёрную кошку в тёмной комнате, особенно если там её нет»… Программа не простейшая, много увязано, и некоторые изменения и то, что они поломали, не видны такому неспециалисту как я.
Принцип реализации цикла - буду ломать голову, я тоже вчера понял про 115+5=120, что нужно добавлять цикл, что я вырезал с argparse, думаю, куда именно его вставить. Надеюсь, с вашими советами и помощью разберусь. За encode() спасибо, сам бы я и не понял!
Потом займусь POST. Потом Докер. Не знаю, если смогу понять и сдать работу, не серчайте.
@Юлия Черкас
 Юлия, я посмотрел форму продления сдачи и … ничего не понял, сдам эту работу, как только разберусь, я вам отдельно вчера написал. Сейчас, с помощью Константина разбираюсь, понимание приходит очень медленно, и даже пройденный курс «Основы Питона» не помогает.
 (edited)


Константин З.
  6 hours ago
@Александр
 Сейчас заметил одну деталь. Позвольте узнать, Вы используете Postman в браузере? Веб-версию?


Константин З.
  6 hours ago
Из скриншотов вижу, что ошибка вылезла, как в веб-версии, но дальнейшие сообщения показали, что Ping sweep у Вас запустился, а это могло произойти только в десктопной версии. Т.к. веб-версия не достанет до Вашего localhost:3009, поэтому возник диссонанс :)
Если сначала пробовали на веб-версии, а потом перешли на десктопную - отлично, так и нужно. С веб-версии Вы не сможете отправлять запросы на свою API


Ганицев Александр Сергеевич
  6 hours ago
@Константин З.
 Я не устанавливал десктопной версии Postman ещё, для запуска сканера лучше установить десктопную?
Я наверное не до конца понял, что такое API.
То есть в моём примере (main.py, содержащая ping sweep и sendhttp функции) это будут те две функции do_GET и do_POST принадлежащие объекту http.server?
Я всё думаю, куда воткнуть цикл из вырезанного аргпарса.
Самое важное для меня это понять, как элементы работают:
Запускаем main.py, стартует http.server
В Postman отправляю request GET, стучусь по localhost:3009(мой порт) в браузере
В поле body указываю IP и номер количества хостов и в нижнем поле вижу результат?
В оригинальном сканере я передавал аргументы через аргпарс: python3 scanner.py scan -i 192.168.1.1 -n 5, здесь не вникну никак, куда их передавать. Мне бы пример кода сканера с API увидеть… В непонимании кода и вся загвоздка, увижу пример, по образу и подобию соберу мою программу, и оформлю в Докере.
Вы уж извините меня Константин, что беспокою своими вопросами, да ещё на выходных. (edited)


Константин З.
  5 hours ago
@Александр

"То есть в моём примере (main.py, содержащая ping sweep и sendhttp функции) это будут те две функции do_GET и do_POST принадлежащие объекту http.server?"
Да, это обработчики, которые будут вызывать Ваши функции ping sweep и sendhttp.
Цикл для перебора можете использовать прямо внутри обработчика do_GET
"Самое важное для меня это понять, как элементы работают:
Запускаем main.py, стартует http.server
В Postman отправляю request GET, стучусь по localhost:3009(мой порт) в браузере
В поле body указываю IP и номер количества хостов и в нижнем поле вижу результат?"
Да, все верно, только без браузера. Суть API как раз в том, чтобы не использовать браузер - Вы посылаете запрос с параметрами, Ваш скрипт выполняет необходимые действия и возвращает Вам ответ (Postman в своём окошке выведет результаты).
Лучше воспользуйтесь десктопной версией Postman, с нее Вы сможете отправлять запрос и видеть ответ сразу. Веб-версия не может отправлять запросы на localhost.
"В оригинальном сканере я передавал аргументы через аргпарс: python3 scanner.py scan -i 192.168.1.1 -n 5, здесь не вникну никак, куда их передавать."
Их передавать нужно в body. Только Вы не просто передаете IP и количество хостов, а нужно еще в самом API еще обрабатывать то, что приходит в body
Набросал пример обработчика do_GET, который выполняет сканирование строго 2-ух хостов, начиная с IP адреса, который я отправил в body. Надеюсь поможет:
def do_GET(self):
    temp = self._set_headers()
    self.send_response(200)
    self.send_header("Content-type", "text/json")
    self.end_headers()
    ip_parts = temp.split('.')
    network_ip = ip_parts[0] + '.' + ip_parts[1] + '.' + ip_parts[2] + '.'
    ping = "ping -c 1 "
    time1 = datetime.datetime.now()
    for ip in range(0, 2):
        addr = network_ip + str(ip)
        print(addr)
        command = ping + addr
        response = os.popen(command)
        res = response.readlines()

        for line in res:
            if (line.count("ttl")):
                self.wfile.write(("\n" + addr + "----- LIVE\n").encode())

    time2 = datetime.datetime.now()
    total_time = time2 - time1
    self.wfile.write((f"Complete! in {total_time}").encode())
Извиняюсь за отсутствие комментариев и неаккуратность, времени было немного)


Константин З.
  5 hours ago
Пример запроса и ответа из Postman:
см. img.png

Константин З.
  5 hours ago
Даже немного накосячил в цикле - цикл должен быть такой:
for ip in range(int(ip_parts[3]), int(ip_parts[3])+2)
(Начальная точка - переданный последний октет, последняя точка - переданный последний октет + 2. В Вашем случае вместо 2 должен быть параметр number_of_hosts)


Ганицев Александр Сергеевич
  4 hours ago
Надеюсь понял Константин, сейчас свет дадут, буду набивать и тестировать. Сложиться сканер, загоню в Докер.


Ганицев Александр Сергеевич
  4 hours ago
Дали свет! Извините ещё раз за то, что задёргал со своими вопросами. Буду ваш пример разбирать и пробовать.

Ганицев Александр Сергеевич
  1 day ago
@Константин З.
 Есть некоторые успехи Константин! С помощью коллег и вашего скрипта, получилось модифицировать мой скрипт,
Вариант main_v3 обработчики вызывают основные функции и после запросов GET и POST, в терминале работает и сканер и HTTP запрос. Но (!), и параметры передаваемые в методы, закодированы в самом скрипте. Postman их не получает.
В варианте, что вы мне подсказали, Postman берёт IP, но я не вижу, как ввести num_scanned_hosts.
Да и с пингом там такая ошибка выходит:
ping: invalid count of packets to transmit: `1192.168.1.0'
192.168.1.1
Понимаю, что это в строке: command = ping + addr
И там и там Postman выдаёт (скриншот).
Большое спасибо вам и Евгению Галушко за совет с циклом, я с ним конкретно застрял. (edited) 
4 files
 

main_v3.py
Python

main_v4_KZ.py
Python
image.png
image.png
PNG
image.png
image.png
PNG


Ганицев Александр Сергеевич
  1 day ago
С пингом решил вопрос: command = ping + ” ” + addr (вставкой пробела). Теперь остаётся вопрос передачи аргументов через Postman и запихивания этого добра в Docker.  Ищу.
Also sent to the channel


Ганицев Александр Сергеевич
  1 day ago
@Константин З.
Добрый день Константин, добрался до ошибки:
    for ip in range(int(ip_parts[3]), int(ip_parts[3]) + 3) :
                    ^^^^^^^^^^^^^^^^
ValueError: invalid literal for int() with base 10: ‘115\\n’
Она кроется здесь - temp = str(content).strip(‘b\‘’), пытаюсь разобраться, мне надо, чтобы октет был  без \\n (там Protected Attribute), ищу, если получится, то я понимаю, что программа будет работать, как задумано и принимать аргумент ip из Postman-а. Там останется так же подправить sendhttp и собирать Doker image. (edited) 


Константин З.
  1 day ago
@Александр
 Добрый день! Возможно при отправке в Postman лишний символ закрался, посмотрите там. Не должно быть ни пробелов, ни переходов на новую строку. Но это костыльное решение, скорее временное
Более оптимальный вариант - фильтровать входящий payload и очищать его от лишних символов.


Ганицев Александр Сергеевич
  1 day ago
@Константин З.
 И я тоже про это подумал, что Postman грешит, в поле отправки перебил IP, убедился, что нет добавочных символов. Потом полез дебажить, процесс уходит вглубь, и на каком-то шаге есть .append(\n) в свойствах объекта, а вывод нашегo temp не выходит изменить, из-за Protected Attribute. Решил введением такой строки:

ip_parts[3] = ip_parts[3].replace('\\n', '')
Сканер и SENDHTTP работают через API Postman.
Собрал образ в Докере, запускаю контейнер, похоже, что do_POST работает, а вот пинг выдаёт:  docker run -p 3009:3009 api_scaner
172.17.0.1 - - [13/Mar/2023 21:11:35] “GET / HTTP/1.1” 200 -
172.17.0.1 - - [13/Mar/2023 21:11:35] “GET / HTTP/1.1" 200 -
/bin/sh: 1: ping: not found
/bin/sh: 1: ping: not found
/bin/sh: 1: ping: not found
/bin/sh: 1: ping: not found
/bin/sh: 1: ping: not found (сканер пингует у меня 5 хостов, я так заложил, так и не разобрался, как в Postman передать два аргумента).
Тут уж я искал, в структуру контейнера лазил, там и bash и sh числятся, но решение для сканера в Postman так и не нашёл.
Знаю, что вы заняты, я накатал простыню, чтоб поймать все ответы сразу. Уж извините меня… (edited) 


Ганицев Александр Сергеевич
  10 hours ago
5 files
 
scanner_works_with_postman_no_docker.png
scanner_works_with_postman_no_docker.png
PNG

main.py
Python

Dockerfile
Plain Text

requirements.txt
C++
image.png
image.png
PNG


Ганицев Александр Сергеевич
  8 hours ago
@Константин З.
 Ещё раз прошу прощения за беспокойство Константин. Я нашёл проблему:
RUN apt-get update
RUN apt-get install -y python
RUN apt-get install -y iputils-ping
Как я добавил в образ установку Питона, пинг в запущеном в Докере контейнере заработал!
Единственный вопрос, который хотелось бы выяснить, как передать для сканера два аргумента в Postman? Функция def do_GET(self)  имеет один аргумент. Да и  do_POST я не никак не разберу, как передавать строку из Postman (SEND).


Константин З.
  5 hours ago
@Александр
 Здравствуйте! Это мне нужно перед Вами извиняться за долгий ответ!
Передача двух аргументов в постман осуществляется через body в заданном Вами формате. Т.е. для пинга Вы просто передавали ip адрес, а для http запроса Вам нужно еще дополнительно написать обработчик, который будет вытаскивать нужные параметры. Вот сравните:
body:
192.168.0.1
(Тут Вы просто целиком берете адрес и засовываем его в temp)
А теперь для реквеста:
body:
{"target": "www.ya.ru", "method":"GET"}
(Тут Вы также целиком берете всю это строку и засовываете в temp. Однако, для того, чтобы вытащить "www.ya.ru" и "GET", которые затем будут Вашими аргументами для функции sendhttp, уже нужно распарсить строку temp. Вы можете это сделать с помощью библиотеки json. Можете просто с помощью методов работы со строками вытащить всё, что идет после подстроки target и это будет переменная target, а все что после подстроки "method" - переменная method. Еще один вариант - сделать strip() и убрать слова target,method, кавычки и скобки, так чтобы остались только нужные параметры. В общем, способов обработать temp много, Вам нужно выбрать какой-то один. Основная задача - передать в payload несколько параметров в четко структурированном виде, а затем эти параметры вытащить из temp)
На мой субъективный взгляд удобнее всего это сделать с помощью библиотеки json, но это не обязательное условие.
Здесь немного не понял, что Вы имели в виду:
"Да и do_POST я не никак не разберу, как передавать строку из Postman (SEND)."
Можете, пожалуйста, подробнее расписать что именно не получается? Если остались вопросы по поводу нескольких аргументов - пишите


Ганицев Александр Сергеевич
  5 hours ago
@Константин З.
 Здравствуйте Константин! Не стоит извинений, работа, студенты, дела, тут время нужно, я всё прекрасно понимаю. Ваша помощь многого стоит, я действительно чувствую, что понемногу разбираюсь и заполняю пробелы в знании IT сферы.
Пока ждал ответа разобрался с Git, потом с тем надоедливым символом ’\\n” в четвертом октете. Потом, когда скрипт заработал, загрузил его в Докер и наконец-то решил проблему с пингом. За помощь не перестану благодарить.
Программирование вещь точная, для отправления запросов, нужен чёткий синтаксис, понимание коего у меня хромает ;о).
Вот где был вопрос:
“body:
192.168.0.1
(Тут Вы просто целиком берете адрес и засовываем его в temp)”
Набивая адрес 192.168.0.1 в Postman request (GET), я получаю в temp строку “192.168.0.1" и она в do_GET обрабатывается как строка. Моя (с вашим кодом) реализация данной функции работает с передаваемым IP, хотелось бы понять, как можно спарсить и обработать 2 аргумента.
А здесь:
“А теперь для реквеста:
body:
{“target”: “www.ya.ru”, “method”:“GET”}
(Тут Вы также целиком берете всю это строку и засовываете в temp.”
В Postman мы передаём строку так:
“target”: “www.ya.ru”, “method”:“GET” или
{“target”: “www.ya.ru”, “method”:“GET”} или
target:www.ya.ru, method:GET?
Она ведь передаётся как целая строка, и эту строку мне надо распарсить и обработать. Т.е. я не понимaю правил отправки запроса и обработки его в do_POST! А вытащив target, www.ya.ru, methot и GET, я смогу их передать в мою
def send_http_request(target: str, method: str = "GET", headers=None, payload=None)
и тогда скрипт запоёт и покажет вывод в Postman-е?
Пересмотрел массу роликов и сайтов, кое-что прояснилось, но если понять, как передаётся и как обрабатывается, то я завершу и сдам работу, обретя не малый опыт (уже почти неделю пилю этот скрипт).
Надеюсь ясно изложил. (edited) 


Константин З.
  4 hours ago
@Александр
"Набивая адрес 192.168.0.1 в Postman request (GET), я получаю в temp строку “192.168.0.1" и она в do_GET обрабатывается как строка. Моя (с вашим кодом) реализация данной функции работает с передаваемым IP, хотелось бы понять, как можно спарсить и обработать 2 аргумента."
Для обоих случаев do_GET и do_POST обработка будет одинаковая. Так что если разберетесь с do_POST, то же самое (в плане множества аргументов) сможете сделать и в do_GET.
"В Postman мы передаём строку так:
“target”: “www.ya.ru”, “method”:“GET” или
{“target”: “www.ya.ru”, “method”:“GET”} или
target:www.ya.ru, method:GET?"
Лучше передавать как {“target”: “www.ya.ru”, “method”:“GET”} . Потому что в таком случае Вы можете использовать библиотеку json. {} вот эти скобочки делают из обычной строки словарь. В котором {"ключ": "значение"}. И Питон умеет с такой структурой работать. Если передадите просто строкой без {}, уже придется самому писать обработку этой строки с нуля.
Вы правы, в любом случае к Вам придет тип string, но внутри него будут уже {}, а питоновская библиотека json умеет работать с такой структурой и для нее это уже не строка, а словарь.
Если же передаете
“target”: “www.ya.ru”, “method”:“GET”
То это также будет просто строка, но Вы уже не сможете использовать библиотеку json. Придется костылями обрабатывать всю эту строку постепенно. Убирать символы, строки и т.д.
По итогу, если работать с json, то у Вас строка temp станет словарем, из которого Вы уже сможете вытаскивать значения по ключу. Ну скажем с помощью json Вы конвертировали строку temp в словарь dict, и теперь dict["target"] - это в аккурат будет строка "www.ya.ru", а dict["method] - строка "GET".
В случае без json вы в temp должны в итоге получить list (список), который ввыглядит как-то так:
["www.ya.ru", "GET"]
И тогда temp[0] - это ваш таргет, temp[1] - это метод.
Дальше сможете спокойно в свою функцию передавать либо temp[0] и temp[1], либо dict["target"] и dict["method"].
"А вытащив target, www.ya.ru, methot и GET, я смогу их передать в мою
def send_http_request(target: str, method: str = "GET", headers=None, payload=None)
и тогда скрипт запоёт и покажет вывод в Postman-е?"
Да! Все верно.
По поводу библиотеки json и как можно вашу строку temp превратить в словарик ключ:значение уже писал в одном из наших обсуждений. Там нужен метод json.loads()


Ганицев Александр Сергеевич
  4 hours ago
@Константин З.
 Благодарю за разъяснения, теперь стало понятно, скоро сяду за реализацию. Напишу, как всё заработает!

ОТЗЫВ от Константина:

Отзыв от Константина Зубченко, приятно!

КОММЕНТАРИИ КОМАНДЫ КУРСА
Александр, здравствуйте Если бы у трудолюбия был амбассадор, Вы бы им определенно стали! Отличная работа, реализовано всё согласно ТЗ: - Присутствует весь необходимый функционал - Реализовано API - Утилита работает в docker - Все исходники загружены на гит Не могу не отметить Ваше качественное ведение репозитория. А также наличия материалов\readme и предыдущих версий программ. Эта "кладовка" Вам обязательно пригодится, когда в будущем будете к ней возвращаться, чтобы повторить тему. Чтобы не потерять навык, советую почитывать уже когда-то озвученную книгу Black Hat Python, Ваших знаний должно хватать для того, чтобы ее осилить. Более того, она продвигает Вас не только в программировании на Python, но и в ИБ в целом. Поздравляю с блестящим выполнением сквозной задачи! Желаю успехов в дальнейших модулях :) По любым вопросам\сложностям можете обращаться в Slack #вводный-курс или в новую Пачку С Уважением, отзыв оставил ментор Зубченко Константин